<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Memeportal — Resizer</title>
<link rel="icon" href="images/logo.png" type="image/png" />
<link rel="stylesheet" href="style.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  /* --- Page‑specific fixes --- */
  
  /* The Preview Container */
  .stage {
    position: relative;
    background: #0b0f17;
    border: 1px solid var(--border);
    border-radius: 14px;
    /* Fixed height constraint prevents buttons from being pushed off */
    height: 500px; 
    max-height: 60vh; 
    width: 100%;
    overflow: hidden; /* Clips anything that tries to escape */
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 20px; /* Breathing room */
    box-sizing: border-box;
  }

  /* The actual Canvas */
  .stage canvas {
    /* CSS handles visual scaling, JS handles resolution */
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 4px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  }

  .checker {
    /* Checkerboard pattern for transparency */
    background: conic-gradient(#141824 25%, #0f1320 0 50%, #141824 0 75%, #0f1320 0) 0 0/20px 20px;
  }

  /* Compact sliders */
  .adj-grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
  .adj-row { display: grid; grid-template-columns: 110px 1fr; align-items: center; gap: 10px; }
  .adj-row label { margin: 0; font-weight: 700; font-size: 0.85rem; }
  .adj-row input[type=range] { width: 100%; }

  @media (min-width: 1200px){
    .adj-grid { grid-template-columns: 1fr 1fr; }
  }

  @media (max-width: 900px){
    .stage { height: 350px; max-height: 50vh; padding: 10px; }
  }
</style>
</head>
<body>
  <div id="site-header"></div>
  <script>
    // load shared nav + burger
    (async()=>{try{
      const host=document.getElementById('site-header');
      host.innerHTML=await (await fetch('nav.html')).text();
      const btn=host.querySelector('.menu-toggle'), menu=host.querySelector('#mobileMenu');
      if(!btn||!menu) return;
      const close=()=>{menu.setAttribute('hidden','');btn.setAttribute('aria-expanded','false');document.removeEventListener('click',away);};
      const open =()=>{menu.removeAttribute('hidden');btn.setAttribute('aria-expanded','true');setTimeout(()=>document.addEventListener('click',away),0);};
      const away=e=>{if(!menu.contains(e.target)&&!btn.contains(e.target)) close();};
      btn.addEventListener('click',e=>{e.stopPropagation();menu.hasAttribute('hidden')?open():close();});
      window.matchMedia('(min-width:900px)').addEventListener?.('change',e=>{if(e.matches) close();});
      close();
    }catch(e){console.warn('nav load failed',e)}})();
  </script>

  <div class="app app--wide">
    <aside>
      <div class="card section" id="uploadCard">
        <h2>Image</h2>
        <div id="drop" class="drop">
          <input id="fileInput" type="file" accept="image/*">
          <div><strong>Drag & drop</strong> an image or <button class="btn ghost" id="browseBtn">Browse</button></div>
          <div class="tiny muted" style="margin-top:6px">Works with PNG, JPG, WebP.</div>
        </div>
        <div id="fileMeta" class="footer">No image loaded.</div>
      </div>

      <div class="card section">
        <h2>Output Settings</h2>
        <div class="grid">
          <div class="two">
            <div>
              <label>Preset</label>
              <select id="preset">
                <option value="custom" selected>Custom size</option>
                <option value="1080x1080">Instagram Post — 1080×1080</option>
                <option value="1080x1920">Story/TikTok — 1080×1920</option>
                <option value="1500x500">X Banner — 1500×500</option>
                <option value="400x400">X Profile — 400×400</option>
                <option value="1280x720">YouTube Thumb — 1280×720</option>
                <option value="1200x630">Open Graph — 1200×630</option>
                <option value="512x512">Telegram Sticker — 512×512</option>
                <option value="128x128">Discord Emoji — 128×128</option>
              </select>
            </div>
            <div class="flex" style="gap:10px">
              <div style="flex:1">
                <label>W</label>
                <input id="outW" type="number" min="8" value="1080">
              </div>
              <div style="flex:1">
                <label>H</label>
                <input id="outH" type="number" min="8" value="1080">
              </div>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Fit mode</label>
              <select id="mode">
                <option value="contain">Fit (contain)</option>
                <option value="cover" selected>Fill (cover)</option>
                <option value="stretch">Stretch</option>
              </select>
            </div>
            <div>
              <label>Background</label>
              <div class="flex">
                <input type="color" id="bgColor" value="#000000">
                <label class="small" style="margin:0 0 0 10px"><input type="checkbox" id="transparent" checked> Transparent</label>
              </div>
            </div>
          </div>

          <div class="two">
            <div>
              <label>Padding</label>
              <input id="padding" type="range" min="0" max="200" value="0">
            </div>
            <div class="flex">
              <div>
                <label>Rotate</label>
                <input id="rotate" type="range" min="-180" max="180" value="0">
              </div>
              <div style="margin-left:10px">
                <label>&nbsp;</label>
                <div class="flex">
                  <label class="small"><input id="flipH" type="checkbox"> Flip H</label>
                  <label class="small"><input id="flipV" type="checkbox" style="margin-left:10px"> Flip V</label>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="card section">
        <h2>Shape & Mask</h2>
        <div class="grid two">
          <div>
            <label>Shape</label>
            <select id="shape">
              <option value="none">None (rectangle)</option>
              <option value="rounded" selected>Rounded</option>
              <option value="circle">Circle</option>
              <option value="squircle">Squircle</option>
              <option value="hex">Hexagon</option>
            </select>
          </div>
          <div>
            <label>Corner radius</label>
            <input id="radius" type="range" min="0" max="200" value="40">
          </div>
        </div>
      </div>

      <div class="card section">
        <h2>Adjustments</h2>
        <div class="adj-grid">
          <div class="adj-row"><label for="adj_b">Brightness</label><input id="adj_b" type="range" min="0" max="2" step="0.01" value="1"></div>
          <div class="adj-row"><label for="adj_c">Contrast</label><input id="adj_c" type="range" min="0" max="2" step="0.01" value="1"></div>
          <div class="adj-row"><label for="adj_s">Saturation</label><input id="adj_s" type="range" min="0" max="2" step="0.01" value="1"></div>
          <div class="adj-row"><label for="adj_h">Hue</label><input id="adj_h" type="range" min="0" max="360" step="1" value="0"></div>
          <div class="adj-row"><label for="adj_blur">Blur</label><input id="adj_blur" type="range" min="0" max="10" step="0.1" value="0"></div>
        </div>
      </div>

      <div class="card section">
        <h2>Background Tool</h2>
        <div class="grid">
          <div class="two">
            <div>
              <label>Solid‑BG Remover</label>
              <input id="rm_tol" type="range" min="0" max="120" value="38">
              <div class="tiny muted">Tolerance</div>
            </div>
            <div>
              <label>Feather</label>
              <input id="rm_feather" type="range" min="0" max="4" step="0.25" value="0.75">
            </div>
          </div>
          <button class="btn" id="btnRemoveBg">Remove Solid Background</button>
        </div>
      </div>

      <div class="card section">
        <h2>Batch export</h2>
        <div class="list" id="presetList"></div>
        <div class="tiny muted">Checked sizes will export to a ZIP.</div>
      </div>

      <div class="card section">
        <div class="toolbar right">
          <button class="btn" id="resetBtn">Reset</button>
          <button class="btn primary" id="renderBtn">Render</button>
          <button class="btn" id="saveBtn">Download</button>
          <button class="btn success" id="zipBtn">Export ZIP</button>
        </div>
      </div>
    </aside>

    <main>
      <div class="card section preview-pane">
        <div class="flex" style="justify-content:space-between;align-items:end">
          <div>
            <div class="kicker">Preview</div>
            <h1 style="font-size:18px;margin-top:6px">Live Output</h1>
          </div>
          <div class="pill"><span id="outSize">—</span></div>
        </div>
        <div class="hr"></div>

        <div class="stage checker">
          <canvas id="canvas"></canvas>
        </div>

        <div class="hr"></div>
        <div class="grid two">
          <div class="two">
            <div>
              <label>Format</label>
              <select id="fmt">
                <option value="image/png" selected>PNG</option>
                <option value="image/webp">WebP</option>
                <option value="image/jpeg">JPG</option>
              </select>
            </div>
            <div>
              <label>Quality</label>
              <input id="quality" type="range" min="0.5" max="1" step="0.01" value="0.95">
            </div>
          </div>
          <div class="flex right">
            <button class="btn" id="copyBtn">Copy</button>
          </div>
        </div>
      </div>
    </main>
  </div>

<script>
(function(){
  const state = { img:null, srcW:0, srcH:0 };
  const el=id=>document.getElementById(id);
  const canvas=el('canvas'), ctx = canvas.getContext('2d');

  // Controls
  const drop=el('drop'), fileInput=el('fileInput'), browseBtn=el('browseBtn'), fileMeta=el('fileMeta');
  const preset=el('preset'), outW=el('outW'), outH=el('outH'), mode=el('mode'), bgColor=el('bgColor'), transparent=el('transparent');
  const padding=el('padding'), rotate=el('rotate'), flipH=el('flipH'), flipV=el('flipV');
  const shape=el('shape'), radius=el('radius');
  const adj_b=el('adj_b'), adj_c=el('adj_c'), adj_s=el('adj_s'), adj_h=el('adj_h'), adj_blur=el('adj_blur');
  const rm_tol=el('rm_tol'), rm_feather=el('rm_feather'), btnRemoveBg=el('btnRemoveBg');
  const renderBtn=el('renderBtn'), saveBtn=el('saveBtn'), copyBtn=el('copyBtn'), zipBtn=el('zipBtn'), resetBtn=el('resetBtn');
  const fmt=el('fmt'), quality=el('quality'), outSize=el('outSize'), presetList=el('presetList');
  const stage = document.querySelector('.stage');

  // --- 1. CORE RENDER LOGIC (FIXED) ---
  function render(){
    // 1. Determine Output Size (The real pixels)
    const W = Math.max(8, Math.min(8192, +outW.value||1080));
    const H = Math.max(8, Math.min(8192, +outH.value||1080));

    // 2. Determine Preview Size (Fitting inside the stage)
    // We calculate a width/height that fits within the .stage box while maintaining W/H aspect ratio
    const boxW = stage.clientWidth - 40; // minus padding
    const boxH = stage.clientHeight - 40; 
    const aspect = W / H;

    let dispW = boxW;
    let dispH = boxW / aspect;

    if (dispH > boxH) {
       dispH = boxH;
       dispW = boxH * aspect;
    }

    // 3. Set Canvas Dimensions
    // We set the "Internal" resolution to the Display size * DPR for crispness
    // We DO NOT set the internal resolution to the real Output Size (W/H) during preview
    // because rendering a 4000px image every frame on a slider drag is slow.
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.round(dispW * dpr);
    canvas.height = Math.round(dispH * dpr);
    
    // Explicit CSS style to force it to fit exactly what we calculated
    canvas.style.width = dispW + 'px';
    canvas.style.height = dispH + 'px';
    
    // Scale context so we can draw using "Display Coordinates" (0..dispW, 0..dispH)
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // 4. Draw Background
    if(!el('transparent').checked){ 
        ctx.fillStyle = bgColor.value; 
        ctx.fillRect(0, 0, dispW, dispH); 
    } else { 
        ctx.clearRect(0, 0, dispW, dispH); 
    }

    if(!state.img){ 
        outSize.textContent = `${W}×${H}`; 
        return; 
    }

    // 5. Calculate Image Placement
    // We treat 'dispW' and 'dispH' as the canvas bounds.
    // The "Padding" slider is relative to the output size, so we scale it down to preview size.
    const scaleRatio = dispW / W; 
    const pad = (+padding.value) * scaleRatio; 
    
    const drawAreaW = dispW - (pad * 2);
    const drawAreaH = dispH - (pad * 2);

    // Fit source image into drawArea based on Mode
    const sw = state.srcW, sh = state.srcH;
    let dw = drawAreaW, dh = drawAreaH;

    if(mode.value === 'contain'){
        const s = Math.min(drawAreaW / sw, drawAreaH / sh);
        dw = sw * s; dh = sh * s;
    } else if(mode.value === 'cover'){
        const s = Math.max(drawAreaW / sw, drawAreaH / sh);
        dw = sw * s; dh = sh * s;
    } 
    // else stretch uses full drawAreaW/H

    const dx = (dispW - dw) / 2;
    const dy = (dispH - dh) / 2;

    // 6. Draw with Transforms & Filters
    ctx.save();
    
    // Apply Mask (scaled to preview size)
    applyMask(ctx, dispW, dispH, (+radius.value) * scaleRatio);

    ctx.translate(dispW/2, dispH/2);
    ctx.scale(flipH.checked?-1:1, flipV.checked?-1:1);
    ctx.rotate((+rotate.value||0) * Math.PI/180);
    ctx.translate(-dispW/2, -dispH/2);

    ctx.filter = `brightness(${adj_b.value}) contrast(${adj_c.value}) saturate(${adj_s.value}) hue-rotate(${adj_h.value}deg) blur(${adj_blur.value}px)`;
    
    ctx.drawImage(state.img, dx, dy, dw, dh);
    ctx.restore();
    ctx.filter = 'none';

    outSize.textContent = `${W}×${H}`;
  }

  // --- 2. EXPORT RENDER LOGIC (FULL RESOLUTION) ---
  // This function is used by Download/Copy to render the full sized image invisible to user, then save it.
  function renderToBlob(callback) {
     const W = +outW.value||1080; 
     const H = +outH.value||1080;
     
     // Hijack the main canvas temporarily (or create new one, but hijacking saves memory)
     // To avoid UI flicker, we usually create a new canvas, but for simplicity let's use a temp one
     const t = document.createElement('canvas');
     t.width = W; t.height = H;
     const tctx = t.getContext('2d');

     // Background
     if(!el('transparent').checked){ 
         tctx.fillStyle = bgColor.value; 
         tctx.fillRect(0, 0, W, H); 
     }

     const pad = +padding.value;
     const drawAreaW = W - (pad * 2);
     const drawAreaH = H - (pad * 2);
     
     const sw = state.srcW, sh = state.srcH;
     let dw = drawAreaW, dh = drawAreaH;

     if(mode.value === 'contain'){
         const s = Math.min(drawAreaW / sw, drawAreaH / sh);
         dw = sw * s; dh = sh * s;
     } else if(mode.value === 'cover'){
         const s = Math.max(drawAreaW / sw, drawAreaH / sh);
         dw = sw * s; dh = sh * s;
     }

     const dx = (W - dw) / 2;
     const dy = (H - dh) / 2;

     tctx.save();
     // Apply Mask (Full Resolution)
     applyMask(tctx, W, H, +radius.value);

     tctx.translate(W/2, H/2);
     tctx.scale(flipH.checked?-1:1, flipV.checked?-1:1);
     tctx.rotate((+rotate.value||0) * Math.PI/180);
     tctx.translate(-W/2, -H/2);

     tctx.filter = `brightness(${adj_b.value}) contrast(${adj_c.value}) saturate(${adj_s.value}) hue-rotate(${adj_h.value}deg) blur(${adj_blur.value}px)`;
     
     tctx.drawImage(state.img, dx, dy, dw, dh);
     tctx.restore();

     const type = fmt.value;
     const q = +quality.value||0.95;
     t.toBlob(callback, type, q);
  }

  // Helper: Masking
  function applyMask(ctx, W, H, r){
    const rr = Math.min(r, Math.min(W,H)/2);
    const sh = shape.value;
    ctx.beginPath();
    if(sh==='none'){ ctx.rect(0,0,W,H); }
    else if(sh==='rounded'){ roundRect(ctx,0,0,W,H,rr); }
    else if(sh==='circle'){ const m=Math.min(W,H); ctx.arc(W/2,H/2,m/2,0,Math.PI*2); }
    else if(sh==='squircle'){
      const p=4, rx=W/2, ry=H/2, cx=W/2, cy=H/2, steps=256; ctx.moveTo(cx+rx,cy);
      for(let i=0;i<=steps;i++){ const t=i/steps*Math.PI*2;
        const x=cx+Math.sign(Math.cos(t))*Math.pow(Math.abs(Math.cos(t)),2/p)*rx;
        const y=cy+Math.sign(Math.sin(t))*Math.pow(Math.abs(Math.sin(t)),2/p)*ry;
        ctx.lineTo(x,y);
      }
    } else if(sh==='hex'){
      const s=6,R=Math.min(W,H)/2,cx=W/2,cy=H/2;
      for(let i=0;i<s;i++){ const a=(Math.PI/3)*i+Math.PI/6, x=cx+Math.cos(a)*R, y=cy+Math.sin(a)*R; i?ctx.lineTo(x,y):ctx.moveTo(x,y); }
      ctx.closePath();
    }
    ctx.clip();
  }
  function roundRect(ctx,x,y,w,h,r){
    const rr=Math.min(r,w/2,h/2);
    ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath();
  }

  // --- 3. EVENT LISTENERS ---

  // Upload
  ['dragenter','dragover'].forEach(evt=>drop.addEventListener(evt,e=>{e.preventDefault();drop.classList.add('drag')}));
  ['dragleave','drop'].forEach(evt=>drop.addEventListener(evt,e=>{e.preventDefault();drop.classList.remove('drag')}));
  drop.addEventListener('drop', e=>{const f=e.dataTransfer.files?.[0]; if(f) loadFile(f);});
  browseBtn.addEventListener('click', ()=>fileInput.click());
  fileInput.addEventListener('change', ()=>{if(fileInput.files[0]) loadFile(fileInput.files[0]);});
  
  function loadFile(file){
    const img=new Image(); 
    img.onload=()=>{
        state.img=img; state.srcW=img.width; state.srcH=img.height; 
        fileMeta.textContent=`${file.name} — ${img.width}×${img.height}`; 
        render();
    };
    img.onerror=()=>alert('Could not load image.');
    img.src=URL.createObjectURL(file);
  }

  // Batch Presets
  const PRESETS = [
    ['Instagram Post',1080,1080], ['Story/TikTok',1080,1920], ['X Banner',1500,500],
    ['X Profile',400,400], ['YouTube Thumb',1280,720], ['Open Graph',1200,630],
    ['Telegram Sticker',512,512], ['Discord Emoji',128,128],
  ];
  function buildBatchPresets(){
    presetList.innerHTML='';
    PRESETS.forEach((p,i)=>{
      const id='pz'+i; const row=document.createElement('label');
      row.innerHTML=`<input type="checkbox" id="${id}" ${i<3?'checked':''}> <span>${p[0]} — ${p[1]}×${p[2]}</span>`;
      presetList.appendChild(row);
    });
  }
  buildBatchPresets();

  // Inputs
  preset.addEventListener('change', ()=>{
    if(preset.value==='custom') return;
    const [w,h]=preset.value.split('x').map(Number);
    outW.value=w; outH.value=h; render();
  });
  
  [outW,outH,mode,bgColor,transparent,padding,rotate,flipH,flipV,shape,radius,fmt,quality].forEach(e=>{
    e.addEventListener('input', render); e.addEventListener('change', render);
  });
  [adj_b,adj_c,adj_s,adj_h,adj_blur].forEach(e=> e.addEventListener('input', render));

  // BG Remover
  btnRemoveBg.addEventListener('click', ()=>{
    if(!state.img){ alert('Load an image first.'); return; }
    // Process on temp canvas
    const t=document.createElement('canvas'); t.width=state.srcW; t.height=state.srcH;
    const tc=t.getContext('2d'); tc.drawImage(state.img,0,0);
    const id=tc.getImageData(0,0,t.width,t.height), d=id.data;
    function px(x,y){const i=(y*id.width+x)*4; return [d[i],d[i+1],d[i+2]];}
    const s=[px(0,0),px(id.width-1,0),px(0,id.height-1),px(id.width-1,id.height-1)];
    const bg=s.reduce((a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],[0,0,0]).map(v=>v/4);
    const tol=+rm_tol.value, feather=+rm_feather.value;
    for(let i=0;i<d.length;i+=4){
      const dr=d[i]-bg[0],dg=d[i+1]-bg[1],db=d[i+2]-bg[2];
      const dist=Math.sqrt(dr*dr+dg*dg+db*db);
      if(dist<tol){ const f=Math.min(1, dist/(tol||1)); const a=(1-f)**feather; d[i+3]=d[i+3]*a; }
    }
    tc.putImageData(id,0,0);
    const cleaned=new Image(); 
    cleaned.onload=()=>{state.img=cleaned; state.srcW=cleaned.width; state.srcH=cleaned.height; render();};
    cleaned.src=t.toDataURL();
  });

  // Buttons
  renderBtn.addEventListener('click', render);
  resetBtn.addEventListener('click', ()=>{
    preset.value='custom'; outW.value=1080; outH.value=1080; mode.value='cover';
    bgColor.value='#000000'; transparent.checked=true; padding.value=0;
    rotate.value=0; flipH.checked=false; flipV.checked=false; shape.value='rounded'; radius.value=40;
    adj_b.value=1; adj_c.value=1; adj_s.value=1; adj_h.value=0; adj_blur.value=0;
    rm_tol.value=38; rm_feather.value=.75; render();
  });

  saveBtn.addEventListener('click', ()=>{
     if(!state.img) return;
     renderToBlob(b=>{
       const a=document.createElement('a');
       const ext = fmt.value.split('/')[1];
       a.href=URL.createObjectURL(b); 
       a.download=`resized_${outW.value}x${outH.value}.${ext}`; 
       a.click();
     });
  });

  copyBtn.addEventListener('click', ()=>{
     if(!state.img) return;
     renderToBlob(async blob=>{
       try{ 
           await navigator.clipboard.write([new ClipboardItem({[fmt.value]:blob})]); 
           const og = copyBtn.textContent;
           copyBtn.textContent='Copied!'; 
           setTimeout(()=>copyBtn.textContent=og, 1200); 
       } catch(e){ alert('Clipboard error: '+e); }
     });
  });

  zipBtn.addEventListener('click', async ()=>{
    if(!state.img){ alert('Load an image first.'); return; }
    const checks=[...presetList.querySelectorAll('input[type=checkbox]')];
    const selected=checks.map((ch,i)=>ch.checked?PRESETS[i]:null).filter(Boolean);
    if(!selected.length){ alert('Pick at least one size.'); return; }
    
    const zip=new JSZip();
    // Temporarily swap global values to render each preset
    const oldW = outW.value, oldH = outH.value;
    
    for(const [label,W,H] of selected){
        outW.value=W; outH.value=H; 
        // We use promise wrapper around renderToBlob
        const blob = await new Promise(res => renderToBlob(res));
        const ext = fmt.value.split('/')[1];
        const safe = label.toLowerCase().replace(/[^a-z0-9]+/g,'_');
        zip.file(`${safe}_${W}x${H}.${ext}`, blob);
    }
    
    // Restore UI
    outW.value=oldW; outH.value=oldH; render();
    
    const content=await zip.generateAsync({type:'blob'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(content); a.download='resized_assets.zip'; a.click();
  });

  window.addEventListener('resize', render);
  render(); // init
})();
</script>
</body>
</html>