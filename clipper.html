<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Memeportal — Clipper</title>
<link rel="stylesheet" href="style.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  /* Page‑specific polish (keeps global style.css intact) */
  .app{grid-template-columns:360px minmax(0,1fr)}
  .player-wrap{display:grid;grid-template-rows:auto 1fr;gap:10px;height:100%}
  .aspect-video{position:relative;width:100%;padding-top:56.25%;background:#000;border-radius:12px;border:1px solid var(--border);overflow:hidden}
  .aspect-video > video{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  .clips-panel{display:grid;grid-template-rows:auto 1fr;gap:10px;height:420px}
  .clips-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px;overflow:auto}
  .clip-card{background:#0b0f17;border:1px solid var(--border);border-radius:12px;padding:8px;display:grid;gap:8px}
  .clip-thumb{aspect-ratio:16/9;background:#000;border-radius:8px;overflow:hidden}
  .toolbar.sticky{position:sticky;top:0;background:linear-gradient(180deg,rgba(0,0,0,.3),rgba(0,0,0,.0));backdrop-filter:saturate(1.1) blur(6px);padding:8px;border-radius:12px;border:1px solid var(--border)}
  .kv{font-size:12px;color:#9aa6c6}
  .kv strong{color:var(--text)}
  /* keep side scroll from eating sliders */
  aside .section{scroll-margin-top:10px}
  @media (max-width: 900px){
    .app{grid-template-columns:1fr}
    .clips-panel{height:360px}
  }
</style>
</head>
<body>
  <!-- nav host (you said you’ll wire it) -->
  <div id="site-header"></div>

  <div class="app">
    <aside>
      <!-- VIDEO -->
      <div class="card section">
        <h2>Video</h2>
        <div class="drop" id="drop">
          <input id="videoFile" type="file" accept="video/*">
          <div><strong>Drag & drop</strong> a video or <button class="btn ghost" id="browseBtn">Browse</button></div>
          <div class="tiny muted">MP4/WebM recommended. Processed 100% in your browser.</div>
        </div>
        <div id="meta" class="footer">No video loaded.</div>
      </div>

      <!-- CLIPS & LENGTH -->
      <div class="card section">
        <h2>Clips & length</h2>
        <div class="grid">
          <div>
            <div class="small muted" style="display:flex;justify-content:space-between">
              <span>Number of clips</span><span id="countLabel">5</span>
            </div>
            <input id="clipCount" type="range" min="1" max="30" value="5">
          </div>
          <div>
            <div class="small muted" style="display:flex;justify-content:space-between">
              <span>Average clip length (seconds)</span><span id="lenLabel">6</span>
            </div>
            <input id="clipLen" type="range" min="1" max="30" value="6">
          </div>
          <div class="flex">
            <input id="vary" type="checkbox" checked>
            <label for="vary" style="margin:0">Vary durations randomly (±50%)</label>
          </div>
          <div class="flex">
            <input id="heur" type="checkbox">
            <label for="heur" style="margin:0">Heuristic: nudge away from big scene changes</label>
          </div>
        </div>
      </div>

      <!-- EXPORT -->
      <div class="card section">
        <h2>Export</h2>
        <div class="grid two">
          <div>
            <label for="fmt">Format</label>
            <select id="fmt">
              <option value="webm">WebM (fast)</option>
              <option value="mp4">MP4 label (falls back to WebM)</option>
            </select>
          </div>
          <div>
            <label for="fps">FPS</label>
            <select id="fps">
              <option>24</option><option selected>30</option><option>60</option>
            </select>
          </div>
        </div>
        <div class="toolbar" style="margin-top:8px">
          <button class="btn" id="clearBtn">Clear</button>
          <button class="btn primary" id="genBtn">Generate clips</button>
        </div>
        <div id="progress" class="tiny muted" style="margin-top:8px">Idle.</div>
        <div class="tiny muted" style="margin-top:8px">Note: Most browsers can’t encode MP4 via MediaRecorder; the MP4 option still produces WebM (labeled accordingly).</div>
      </div>
    </aside>

    <main>
      <div class="card section" style="height:100%">
        <div class="player-wrap">
          <div>
            <div class="kicker">Preview</div>
          </div>
          <div class="aspect-video">
            <video id="preview" controls playsinline></video>
          </div>

          <div class="clips-panel" style="margin-top:12px">
            <div class="toolbar sticky" style="display:flex;gap:10px;align-items:center">
              <div class="kicker" style="flex:1">Generated clips</div>
              <button class="btn success" id="zipBtn" disabled>Download All (ZIP)</button>
            </div>
            <div id="clips" class="clips-grid"></div>
          </div>
        </div>
      </div>
    </main>
  </div>

<script>
(function(){
  // ---------- Elements
  const $ = id => document.getElementById(id);
  const fileInput = $('videoFile'), browseBtn=$('browseBtn'), drop=$('drop');
  const preview = $('preview'), meta=$('meta'), progress=$('progress');
  const clipCount=$('clipCount'), clipLen=$('clipLen'), countLabel=$('countLabel'), lenLabel=$('lenLabel');
  const vary=$('vary'), heur=$('heur'), fmt=$('fmt'), fps=$('fps');
  const genBtn=$('genBtn'), clearBtn=$('clearBtn'), clipsEl=$('clips'), zipBtn=$('zipBtn');

  // ---------- State
  let srcBlob=null, srcURL='', clipList=[];
  const procVideo = document.createElement('video'); procVideo.playsInline = true; procVideo.muted = true;
  const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');

  // ---------- UI helpers
  function setProgress(text){ progress.textContent=text; }
  function updateMeta(){
    if(!procVideo.duration || !isFinite(procVideo.duration)){ meta.textContent='No video loaded.'; return; }
    const dur = formatTime(procVideo.duration);
    meta.innerHTML = `Duration: <strong>${dur}</strong> • Resolution: <strong>${procVideo.videoWidth}×${procVideo.videoHeight}</strong>`;
  }
  function formatTime(s){ if(!isFinite(s)) return '--:--'; const m=Math.floor(s/60).toString().padStart(2,'0'); const ss=Math.floor(s%60).toString().padStart(2,'0'); return `${m}:${ss}`; }

  clipCount.addEventListener('input',()=>countLabel.textContent=clipCount.value);
  clipLen.addEventListener('input',()=>lenLabel.textContent=clipLen.value);

  // ---------- File handling (drag + browse)
  browseBtn.addEventListener('click',()=>fileInput.click());
  ['dragenter','dragover'].forEach(evt=>drop.addEventListener(evt,e=>{e.preventDefault();drop.classList.add('drag');}));
  ;['dragleave','drop'].forEach(evt=>drop.addEventListener(evt,e=>{e.preventDefault();drop.classList.remove('drag');}));
  drop.addEventListener('drop', e=>{ if(e.dataTransfer.files[0]) loadFile(e.dataTransfer.files[0]); });
  fileInput.addEventListener('change',()=>{ if(fileInput.files[0]) loadFile(fileInput.files[0]); });

  async function loadFile(f){
    srcBlob = f; if(srcURL) URL.revokeObjectURL(srcURL);
    srcURL = URL.createObjectURL(f);
    preview.src = srcURL; preview.load();
    procVideo.src = srcURL; procVideo.load();
    await new Promise(r=>procVideo.addEventListener('loadedmetadata', r, {once:true}));
    updateMeta();
    clipsEl.innerHTML=''; clipList=[]; zipBtn.disabled=true;
    setProgress('Ready.');
  }

  clearBtn.addEventListener('click', ()=>{
    if(srcURL) URL.revokeObjectURL(srcURL);
    srcBlob=null; srcURL=''; preview.removeAttribute('src'); procVideo.removeAttribute('src');
    fileInput.value=''; clipsEl.innerHTML=''; clipList=[]; zipBtn.disabled=true;
    setProgress('Cleared.'); meta.textContent='No video loaded.';
  });

  // ---------- Core clip generation
  genBtn.addEventListener('click', generateClips);
  async function generateClips(){
    if(!srcBlob){ alert('Upload a video first.'); return; }
    const n = +clipCount.value, avg = +clipLen.value, useHeur = heur.checked;
    const total = procVideo.duration;
    if(!isFinite(total) || total<=0){ alert('Could not read duration.'); return; }

    // random windows
    const windows = [];
    for(let i=0;i<n;i++){
      let dur = avg;
      if(vary.checked){ const delta = avg*0.5; dur = Math.max(0.5, avg + (Math.random()*2-1)*delta); }
      const start = Math.max(0, Math.random()*Math.max(0,total-dur));
      windows.push({start, dur});
    }

    if(useHeur){ setProgress('Scanning for scene changes...'); await nudgeAwayFromSceneChanges(windows); }

    // ensure canvas size
    const W = procVideo.videoWidth || 1280, H = procVideo.videoHeight || 720;
    canvas.width = W; canvas.height = H;

    clipsEl.innerHTML=''; clipList=[]; zipBtn.disabled=true;
    for(let i=0;i<windows.length;i++){
      const {start,dur} = windows[i];
      setProgress(`Rendering clip ${i+1}/${windows.length}...`);
      try{
        const blob = await capture(start,dur,W,H);
        const url = URL.createObjectURL(blob);
        const label = (fmt.value==='mp4'?'mp4-labeled':'webm');
        clipList.push({blob,url,label,idx:i+1,start,dur});
        addClipCard(clipList.at(-1));
      }catch(err){ console.error(err); }
    }
    setProgress(`Done — ${clipList.length} clip${clipList.length===1?'':'s'} ready.`);
    zipBtn.disabled = clipList.length===0;
  }

  function capture(start, dur, W, H){
    return new Promise((resolve, reject)=>{
      const stream = canvas.captureStream(parseInt(fps.value,10)||30);
      let mime = 'video/webm;codecs=vp9';
      if(fmt.value==='mp4') mime = 'video/webm;codecs=vp9'; // label only

      let mr;
      try{ mr = new MediaRecorder(stream,{mimeType:mime}); }
      catch(e){ try{ mr = new MediaRecorder(stream); }catch(err){ return reject(new Error('MediaRecorder not supported')); } }

      const chunks=[];
      mr.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
      mr.onstop = ()=> resolve(new Blob(chunks,{type:mime}));

      procVideo.pause();
      procVideo.currentTime = Math.min(procVideo.duration-0.01, Math.max(0,start));

      procVideo.addEventListener('seeked', ()=>{
        mr.start(250);
        procVideo.play().catch(()=>reject(new Error('Autoplay blocked')));
        const startMs = performance.now();

        const draw = ()=>{
          // cover draw
          const vw = procVideo.videoWidth, vh = procVideo.videoHeight;
          const s = Math.max(W/vw, H/vh);
          const sw = W/s, sh = H/s, sx = (vw-sw)/2, sy = (vh-sh)/2;
          try{ ctx.drawImage(procVideo, sx, sy, sw, sh, 0, 0, W, H); }catch(e){}
          if(((performance.now()-startMs)/1000) >= dur){
            procVideo.pause(); mr.stop(); return;
          }
          requestAnimationFrame(draw);
        };
        requestAnimationFrame(draw);
      }, {once:true});
    });
  }

  function addClipCard(clip){
    const card = document.createElement('div');
    card.className = 'clip-card';
    card.innerHTML = `
      <div class="clip-thumb"><video src="${clip.url}" controls playsinline style="width:100%;height:100%;object-fit:cover"></video></div>
      <div class="kv">Clip ${clip.idx} • ${formatTime(clip.start)} • ${Math.round(clip.dur)}s</div>
      <div class="toolbar right">
        <a class="btn" download="clip-${clip.idx}.${clip.label==='webm'?'webm':'webm'}" href="${clip.url}">Download</a>
      </div>`;
    clipsEl.appendChild(card);
  }

  // Simple scene‑change heuristic (brightness deltas)
  async function nudgeAwayFromSceneChanges(windows){
    const v = procVideo, W = 320, H = Math.round((v.videoHeight/v.videoWidth)*W)||180;
    canvas.width=W; canvas.height=H;
    const samples = Math.min(80, Math.round(v.duration));
    const times = [...Array(samples)].map((_,i)=> (i*v.duration)/samples);
    const br = [];

    await new Promise((resolve)=>{
      let i=0;
      const snap=()=>{ try{ ctx.drawImage(v,0,0,W,H); }catch(e){} const d=ctx.getImageData(0,0,W,H).data; let s=0; for(let k=0;k<d.length;k+=4){ s+=(d[k]+d[k+1]+d[k+2])/3; } br.push(s/(d.length/4)); };
      const next=()=>{ if(i>=times.length){ resolve(); return; }
        v.currentTime=Math.min(v.duration-0.01,times[i]);
        v.addEventListener('seeked',()=>{ snap(); i++; setTimeout(next,25); },{once:true});
      }; next();
    });

    const deltas = br.map((b,i)=> i?Math.abs(b-br[i-1]):0);
    const global = Math.max(...deltas)||1;
    windows.forEach(w=>{
      const idx = Math.floor((w.start/v.duration)*deltas.length);
      const local = deltas.slice(Math.max(0,idx-2), Math.min(deltas.length,idx+3));
      if(Math.max(...local) > global*0.65){ w.start = Math.max(0, w.start - (0.8+Math.random()*0.6)); }
    });
  }

  // ---------- ZIP all
  zipBtn.addEventListener('click', async ()=>{
    if(!clipList.length) return;
    zipBtn.disabled = true; zipBtn.textContent = 'Zipping...';
    const zip = new JSZip();
    for(let i=0;i<clipList.length;i++){
      const arr = await clipList[i].blob.arrayBuffer();
      zip.file(`clip-${(i+1).toString().padStart(2,'0')}.webm`, arr);
    }
    const content = await zip.generateAsync({type:'blob'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(content);
    a.download = 'clips.zip';
    a.click();
    zipBtn.textContent = 'Download All (ZIP)'; zipBtn.disabled=false;
  });
})();
</script>
</body>
</html>
