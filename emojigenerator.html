<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Memeportal — 3D Emoji Tools</title>
<script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<link rel="stylesheet" href="style.css" />

<style>
    /* Specific styles for the 3D preview to look good within your theme */
    #previewContainer {
        width: 100%;
        max-width: 520px;
        border-radius: 12px;
        overflow: hidden;
        /* The dark gradient needed for the coin to pop */
        background: radial-gradient(circle at 20% 0%, #222a56, #050814 60%);
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        margin-bottom: 1rem;
        aspect-ratio: 1 / 1; 
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #previewContainer canvas {
        display: block;
        width: 100% !important; 
        height: auto !important;
    }
    .range-group { margin-bottom: 8px; }
    .range-group label { display:flex; justify-content:space-between; font-size:0.85rem; opacity:0.8; margin-bottom:2px; }
    .range-group input { width:100%; }
    .radio-group { display: flex; gap: 10px; font-size: 0.9rem; margin-bottom: 8px; }
    .radio-group label { display: flex; align-items: center; gap: 4px; font-weight: normal; cursor: pointer;}
</style>
</head>
<body>
  <div id="site-header"></div>
<script>
  async function loadNav(){
    try{
      const host = document.getElementById('site-header');
      host.innerHTML = await (await fetch('nav.html')).text();
      const btn  = host.querySelector('.menu-toggle');
      const menu = host.querySelector('#mobileMenu');
      if(!btn || !menu) return;
      const close = ()=>{
        menu.setAttribute('hidden','');
        btn.setAttribute('aria-expanded','false');
        document.removeEventListener('click', clickAway);
      };
      const open = ()=>{
        menu.removeAttribute('hidden');
        btn.setAttribute('aria-expanded','true');
        setTimeout(()=>document.addEventListener('click', clickAway),0);
      };
      const clickAway = (e)=>{
        if(!menu.contains(e.target) && !btn.contains(e.target)) close();
      };
      btn.addEventListener('click', (e)=>{
        e.stopPropagation();
        if(menu.hasAttribute('hidden')) open(); else close();
      });
      const mq = window.matchMedia('(min-width: 900px)');
      mq.addEventListener?.('change', e=>{ if(e.matches) close(); });
      close();
    }catch(e){ console.warn('nav load failed', e); }
  }
  loadNav();
</script>

  <div class="app" style="grid-template-columns:380px minmax(0,1fr)">
    <aside>
      <div class="card section">
        <h2>Static Emoji (100×100)</h2>
        <div class="grid">
          <div class="drop" id="eDrop">
            <input id="eFiles" type="file" accept="image/*" multiple>
            <div><strong>Drag & drop</strong> PNG/WebP here or <button class="btn ghost" id="eBrowse">Browse</button></div>
            <div class="tiny muted" style="margin-top:6px">Images are resized to <strong>100×100</strong> with transparency kept.</div>
          </div>
          <div class="toolbar right">
            <button class="btn" id="eClear">Clear</button>
            <button class="btn success" id="eZip">Export ZIP</button>
          </div>
        </div>
      </div>

      <div class="card section">
        <h2>3D Coin Video (WebM)</h2>
        <div class="grid">
          
          <div class="two">
             <div>
                <label>Front Image</label>
                <input id="imageInput" type="file" accept="image/*" />
             </div>
             <div>
                <label>Back (Optional)</label>
                <input id="backImageInput" type="file" accept="image/*" />
             </div>
          </div>

          <div class="two">
            <div>
              <label for="coinTint">Coin Tint</label>
              <input type="color" id="coinTint" value="#00d1ff">
            </div>
            <div>
              <label for="rimColor">Rim Color</label>
              <input type="color" id="rimColor" value="#ff0bd8">
            </div>
          </div>

          <div style="margin-bottom:8px;">
            <label>Style</label>
            <div class="radio-group">
                <label><input type="radio" name="styleMode" value="glossy" checked> Metallic</label>
                <label><input type="radio" name="styleMode" value="cartoon"> Flat/Toon</label>
            </div>
          </div>

          <div class="range-group">
            <label><span>Speed</span> <span id="speedVal">1.0s</span></label>
            <input type="range" id="speed" min="0.4" max="3" step="0.1" value="1.0">
          </div>
          
          <div class="range-group">
            <label><span>Thickness</span></label>
            <input type="range" id="thickness" min="0.05" max="0.3" step="0.01" value="0.15">
          </div>

          <div class="range-group">
            <label><span>Front Rotation Fix</span> <input type="number" id="imageRotationNumber" value="0" style="width:50px; height:20px; padding:0;"/></label>
            <input type="range" id="imageRotation" min="0" max="360" step="1" value="0">
          </div>
          <div class="range-group">
            <label><span>Back Rotation Fix</span> <input type="number" id="backRotationNumber" value="0" style="width:50px; height:20px; padding:0;"/></label>
            <input type="range" id="backRotation" min="0" max="360" step="1" value="0">
          </div>

          <div class="hr"></div>
          <div class="two">
             <div>
                <label>Export Mode</label>
                <div class="radio-group" style="flex-direction: column; gap:4px;">
                    <label><input type="radio" name="exportMode" value="sticker" checked> Sticker (512px)</label>
                    <label><input type="radio" name="exportMode" value="emoji"> Emoji (100px)</label>
                </div>
             </div>
             <div>
                <label>FPS</label>
                <input type="number" id="fps" min="5" max="60" step="1" value="30">
             </div>
          </div>

          <div class="range-group">
             <label><span>Bitrate (Quality)</span> <span id="bitrateVal">400 kbps</span></label>
             <input type="range" id="bitrateRange" min="40" max="1200" step="10" value="400">
             <div class="tiny muted" id="sizeEst">Est. size: - KB</div>
          </div>

          <div class="toolbar right" style="margin-top:10px;">
            <button class="btn ghost" id="toggleSpinBtn">Pause</button>
            <button class="btn" id="exportBtn">Export WebM</button>
          </div>
          <div class="tiny muted" style="text-align:right;">Captures 1 full spin.</div>

        </div>
      </div>

      <div class="card section">
        <h2>Telegram Video Requirements</h2>
        <ul class="tiny muted" style="margin:0 0 8px 18px;line-height:1.45">
          <li><strong>Video Stickers:</strong> 512×512, VP9 WebM, &le; 256 KB, 30 FPS.</li>
          <li><strong>Video Emoji:</strong> 100×100, VP9 WebM, &le; 64 KB, 30 FPS.</li>
          <li>Duration must be &le; 3 seconds.</li>
          <li>This tool automatically loops 1 spin and encodes to VP9 WebM.</li>
        </ul>
      </div>
    </aside>

    <main>
      <div class="card section" style="display:grid;gap:12px">
        <div class="kicker">3D Live Preview</div>
        
        <div id="previewContainer"></div>
        
        <div class="hr"></div>
        <h2>Static Emoji Output</h2>
        <div id="emojiGrid" class="preview-grid"></div>
      </div>
    </main>
  </div>

<script>
window.addEventListener('load', function(){

  // ==========================================
  // 1. STATIC EMOJI TOOL (Legacy Code)
  // ==========================================
  const eDrop=document.getElementById('eDrop'), eFiles=document.getElementById('eFiles'), eBrowse=document.getElementById('eBrowse');
  const eGrid=document.getElementById('emojiGrid');
  const eZipBtn=document.getElementById('eZip'); const eClearBtn=document.getElementById('eClear');
  const eState=[]; 

  ['dragenter','dragover'].forEach(evt=>eDrop.addEventListener(evt,e=>{e.preventDefault();eDrop.classList.add('drag')}));
  ['dragleave','drop'].forEach(evt=>eDrop.addEventListener(evt,e=>{e.preventDefault();eDrop.classList.remove('drag')}));
  eDrop.addEventListener('drop', e=>handleEmojiFiles(e.dataTransfer.files));
  eBrowse.addEventListener('click',()=>eFiles.click()); eFiles.addEventListener('change',()=>handleEmojiFiles(eFiles.files));

  function handleEmojiFiles(files){
    const list=[...files].filter(f=>/^image\//.test(f.type)); if(!list.length) return;
    list.forEach(file=>{ const img=new Image(); img.onload=()=>{ const c=resizeTo100(img); addEmojiThumb(c, file.name.replace(/\.[^.]+$/, '')); }; img.src=URL.createObjectURL(file); });
  }
  function resizeTo100(img){ const c=document.createElement('canvas'); c.width=100; c.height=100; const ctx=c.getContext('2d'); ctx.clearRect(0,0,100,100); 
    const s=Math.min(100/img.width, 100/img.height); const w=img.width*s, h=img.height*s; ctx.drawImage(img,(100-w)/2,(100-h)/2,w,h); return c; }
  function addEmojiThumb(canvas, base){ const wrap=document.createElement('div'); wrap.className='thumb checkerboard'; const a=document.createElement('a'); a.className='btn'; a.textContent='PNG'; a.download=base+'.png'; a.href=canvas.toDataURL('image/png'); const actions=document.createElement('div'); actions.className='actions'; actions.appendChild(a); wrap.appendChild(canvas); wrap.appendChild(actions); eGrid.appendChild(wrap); eState.push({name:a.download, canvas}); }
  eClearBtn.addEventListener('click',()=>{eGrid.innerHTML=''; eState.length=0;});
  eZipBtn.addEventListener('click', async ()=>{ if(!eState.length) return alert('Add some images first.'); const zip=new JSZip(); for(const {canvas,name} of eState){ const blob=await new Promise(res=>canvas.toBlob(res,'image/png')); zip.file(name, blob); } const content=await zip.generateAsync({type:'blob'}); const a=document.createElement('a'); a.href=URL.createObjectURL(content); a.download='emoji_static_100.zip'; a.click(); });


  // ==========================================
  // 2. 3D COIN GENERATOR (New Logic)
  // ==========================================

    const imageInput       = document.getElementById('imageInput');
    const backImageInput   = document.getElementById('backImageInput');
    const coinTintIn       = document.getElementById('coinTint');
    const rimColorIn       = document.getElementById('rimColor');
    const speedIn          = document.getElementById('speed');
    const thicknessIn      = document.getElementById('thickness');
    
    // Front Rotation Controls
    const imageRotSlider   = document.getElementById('imageRotation');
    const imageRotNumber   = document.getElementById('imageRotationNumber');
    
    // Back Rotation Controls
    const backRotSlider    = document.getElementById('backRotation');
    const backRotNumber    = document.getElementById('backRotationNumber');

    const toggleSpin       = document.getElementById('toggleSpinBtn');
    const exportBtn        = document.getElementById('exportBtn');
    
    const fpsIn            = document.getElementById('fps');
    const bitrateRange     = document.getElementById('bitrateRange');
    const bitrateVal       = document.getElementById('bitrateVal');
    const sizeEst          = document.getElementById('sizeEst');
    const previewContainer = document.getElementById('previewContainer');
    const modeRadios       = document.querySelectorAll('input[name="exportMode"]');
    const styleRadios      = document.querySelectorAll('input[name="styleMode"]');
    const speedValDisplay  = document.getElementById('speedVal');

    // THREE basics
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(30, 1, 0.1, 10);
    camera.position.set(0, 0, 2.4);

    const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        premultipliedAlpha: true
    });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setClearColor(0x000000, 0);
    renderer.outputEncoding = THREE.sRGBEncoding;
    previewContainer.appendChild(renderer.domElement);

    let currentMode = 'sticker';
    let exportSize = 512;

    function updateRendererSize() {
        // We only change the internal render size, CSS handles display size
        exportSize = currentMode === 'emoji' ? 100 : 512;
        renderer.setSize(exportSize, exportSize, false);
    }
    updateRendererSize();

    function updateBitrateLabel(){
        let kbps = parseInt(bitrateRange.value) || 400;
        bitrateVal.textContent = kbps + " kbps";

        const duration = Math.max(parseFloat(speedIn.value) || 1.0, 0.3);
        const estBytes = (kbps * 1000 * duration) / 8;
        const estKB    = estBytes / 1024;

        sizeEst.textContent = `Est. size: ~${estKB.toFixed(1)} KB (duration ${duration.toFixed(2)}s)`;
    }

    bitrateRange.addEventListener('input', updateBitrateLabel);

    modeRadios.forEach(r => {
        r.addEventListener('change', () => {
            currentMode = Array.from(modeRadios).find(m => m.checked).value;
            updateRendererSize();
            updateBitrateLabel();
            rebuildCoin();
        });
    });

    // Lights
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.4);
    keyLight.position.set(3, 4, 5);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0x66aaff, 0.9);
    rimLight.position.set(-4, 2, -3);
    scene.add(rimLight);

    const bottomLight = new THREE.DirectionalLight(0x00d0ff, 0.7);
    bottomLight.position.set(0, -3, 3);
    scene.add(bottomLight);

    scene.add(new THREE.AmbientLight(0x555566, 0.9));

    let coinGroup = null;
    let baseFaceTexture = null;
    let baseBackTexture = null;

    let running = true;
    let speed = parseFloat(speedIn.value);
    let thickness = parseFloat(thicknessIn.value);
    
    let imageRotationDeg = parseFloat(imageRotSlider.value);
    let backRotationDeg  = parseFloat(backRotSlider.value);

    let lastTime = performance.now();

    let exporting = false;
    let exportDuration = speed;
    let exportStartTime = 0;
    let exportBaseRotation = 0;

    let currentStyle = 'glossy';

    styleRadios.forEach(function(r){
        r.addEventListener('change', function(){
            currentStyle = Array.from(styleRadios).find(m => m.checked).value;
            rebuildCoin();
        });
    });

    function makeFaceTextureFromImage(img){
        const size = 1024;
        const c = document.createElement('canvas');
        c.width = c.height = size;
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,size,size);

        ctx.save();
        ctx.beginPath();
        ctx.arc(size/2,size/2,size*0.46,0,Math.PI*2);
        ctx.closePath();
        ctx.clip();

        const s = Math.min(img.width, img.height);
        const sx = (img.width - s)/2;
        const sy = (img.height - s)/2;
        ctx.drawImage(img, sx, sy, s, s, size*0.04, size*0.04, size*0.92, size*0.92);
        ctx.restore();

        const grd = ctx.createRadialGradient(size/2,size/2,size*0.15,size/2,size/2,size*0.5);
        grd.addColorStop(0,"rgba(0,0,0,0)");
        grd.addColorStop(1,"rgba(0,0,0,0.35)");
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(size/2,size/2,size*0.46,0,Math.PI*2);
        ctx.fill();

        // slight global soften to reduce contrast
        ctx.fillStyle = 'rgba(255,255,255,0.04)';
        ctx.fillRect(0,0,size,size);

        const tex = new THREE.CanvasTexture(c);
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        tex.encoding = THREE.sRGBEncoding;
        tex.needsUpdate = true;
        return tex;
    }

    function createFaceTextures(){
        let front = null;
        if (baseFaceTexture) {
            front = baseFaceTexture.clone();
            front.center.set(0.5, 0.5);
            front.rotation = THREE.MathUtils.degToRad(imageRotationDeg);
            front.needsUpdate = true;
        }

        let back = null;
        const source = baseBackTexture || baseFaceTexture;
        
        if (source) {
            back = source.clone();
            back.center.set(0.5, 0.5);
            back.rotation = THREE.MathUtils.degToRad(backRotationDeg);
            back.needsUpdate = true;
        }

        return { front, back };
    }

    function safeDisposeMesh(obj){
        if (!obj.isMesh) return;
        const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
        mats.forEach(function(m){
            if (!m) return;
            if (m.map && typeof m.map.dispose === 'function') m.map.dispose();
            m.dispose && m.dispose();
        });
        obj.geometry && obj.geometry.dispose && obj.geometry.dispose();
    }

    function rebuildCoin(){
        if(coinGroup){
            scene.remove(coinGroup);
            coinGroup.traverse(safeDisposeMesh);
            coinGroup = null;
        }

        const radius = 0.55;
        const height = thickness;
        const segments = 160;

        const textures = createFaceTextures();
        const frontTex = textures.front;
        const backTex  = textures.back;

        let rimColor  = new THREE.Color(rimColorIn.value);
        let faceColor = new THREE.Color(coinTintIn.value);

        const glossyRim = { metalness: 1.0, roughness: 0.15, flatShading: false };
        const glossyFace = { metalness: 0.65, roughness: 0.3, flatShading: false };
        const cartoonCommon = { metalness: 0.05, roughness: 0.6, flatShading: true };

        let rimParams  = currentStyle === 'glossy' ? { ...glossyRim }  : { ...cartoonCommon };
        let faceParams = currentStyle === 'glossy' ? { ...glossyFace } : { ...cartoonCommon };

        if (currentMode === 'emoji') {
            const white = new THREE.Color(0xffffff);
            rimColor.lerp(white, 0.2);
            faceColor.lerp(white, 0.2);
            rimParams.metalness  = Math.min(rimParams.metalness, 0.4);
            rimParams.roughness  = Math.max(rimParams.roughness, 0.5);
            faceParams.metalness = Math.min(faceParams.metalness, 0.35);
            faceParams.roughness = Math.max(faceParams.roughness, 0.55);
        }

        const rimMat = new THREE.MeshStandardMaterial({ color: rimColor, ...rimParams });
        const faceMat = new THREE.MeshStandardMaterial({ color: faceColor, map: frontTex || null, ...faceParams });
        const backMat = new THREE.MeshStandardMaterial({ color: faceColor.clone(), map: backTex || null, ...faceParams });

        const cylinderGeom = new THREE.CylinderGeometry(radius, radius, height, segments, 1, false);
        cylinderGeom.rotateX(Math.PI / 2); // stand upright

        const coinMesh = new THREE.Mesh(cylinderGeom, [rimMat, faceMat, backMat]);

        coinGroup = new THREE.Group();
        coinGroup.add(coinMesh);
        coinGroup.rotation.set(0, 0, 0);
        scene.add(coinGroup);
    }

    function updateSettings(){
        speed            = parseFloat(speedIn.value);
        thickness        = parseFloat(thicknessIn.value);
        imageRotationDeg = parseFloat(imageRotSlider.value);
        backRotationDeg  = parseFloat(backRotSlider.value);
        
        exportDuration   = speed;
        speedValDisplay.innerText = speed.toFixed(1) + "s";

        rebuildCoin();
        updateBitrateLabel();
    }

    [coinTintIn, rimColorIn, speedIn, thicknessIn].forEach(function(el){
        el.addEventListener('input', updateSettings);
    });

    // Rotation Sync Handlers
    function syncRotationInputs(from, slider, number){
        if (from === 'slider') { number.value = slider.value; } 
        else if (from === 'number') {
            let v = parseFloat(number.value) || 0;
            v = ((v % 360) + 360) % 360;
            number.value = v;
            slider.value = v;
        }
    }
    imageRotSlider.addEventListener('input', () => { syncRotationInputs('slider', imageRotSlider, imageRotNumber); updateSettings(); });
    imageRotNumber.addEventListener('input', () => { syncRotationInputs('number', imageRotSlider, imageRotNumber); updateSettings(); });
    backRotSlider.addEventListener('input', () => { syncRotationInputs('slider', backRotSlider, backRotNumber); updateSettings(); });
    backRotNumber.addEventListener('input', () => { syncRotationInputs('number', backRotSlider, backRotNumber); updateSettings(); });


    imageInput.addEventListener('change', function(e){
        const file = e.target.files[0];
        if(!file) return;
        const img = new Image();
        img.onload = function(){
            baseFaceTexture = makeFaceTextureFromImage(img);
            rebuildCoin();
        };
        img.src = URL.createObjectURL(file);
    });

    backImageInput.addEventListener('change', function(e){
        const file = e.target.files[0];
        if(!file) return;
        const img = new Image();
        img.onload = function(){
            baseBackTexture = makeFaceTextureFromImage(img);
            rebuildCoin();
        };
        img.src = URL.createObjectURL(file);
    });

    toggleSpin.addEventListener('click', function(){
        running = !running;
        toggleSpin.textContent = running ? 'Pause' : 'Play';
    });

    // Initialize
    rebuildCoin();
    updateBitrateLabel();

    function animate(now){
        const dt = (now - lastTime) / 1000;
        lastTime = now;

        if(coinGroup){
            if (exporting) {
                const t = (now - exportStartTime) / 1000;
                const phase = Math.min(t / exportDuration, 1);
                coinGroup.rotation.y = exportBaseRotation + phase * Math.PI * 2;
            } else if (running) {
                const turnPerSec = 1 / speed;
                coinGroup.rotation.y += dt * turnPerSec * Math.PI * 2;
            }
        }
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // EXPORT
    exportBtn.addEventListener('click', function () {
        const duration = Math.max(exportDuration || 1.0, 0.3);
        let fps = parseInt(fpsIn.value) || 30;
        fps = Math.min(Math.max(fps, 5), 60);

        let kbps = parseInt(bitrateRange.value) || 400;
        kbps = Math.max(40, Math.min(kbps, 1200));
        
        const bitrate = kbps * 1000;
        const prevRunning = running;
        const prevPixelRatio = renderer.getPixelRatio();
        const targetSize = (currentMode === 'emoji') ? 100 : 512;

        if (coinGroup) {
            exportBaseRotation = 0;
            coinGroup.rotation.y = 0;
        }

        renderer.setPixelRatio(1);
        renderer.setSize(targetSize, targetSize, false);

        const stream = renderer.domElement.captureStream(fps);
        let chunks = [];
        let recorder;

        try {
            recorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: bitrate
            });
        } catch (e) {
            alert('VP9 WebM export not supported by this browser. Please use Chrome, Edge or Brave on Desktop.');
            renderer.setPixelRatio(prevPixelRatio);
            updateRendererSize();
            return;
        }

        running = true;
        toggleSpin.textContent = 'Recording...';
        toggleSpin.disabled = true;
        exportBtn.disabled = true;
        
        exporting = true;
        exportStartTime = performance.now();

        recorder.ondataavailable = function (e) {
            if (e.data && e.data.size > 0) chunks.push(e.data);
        };

        recorder.onstop = function () {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (currentMode === 'emoji' ? 'coin-emoji-100.webm' : 'coin-sticker-512.webm');
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);

            exporting = false;
            running = prevRunning;
            toggleSpin.textContent = running ? 'Pause' : 'Play';
            toggleSpin.disabled = false;
            exportBtn.disabled = false;

            renderer.setPixelRatio(prevPixelRatio);
            updateRendererSize();
            stream.getTracks().forEach(t => t.stop());
        };

        recorder.start();
        setTimeout(function () {
            recorder.stop();
        }, duration * 1000);
    });

});
</script>
</body>
</html>